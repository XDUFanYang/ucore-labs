# 6.1 非连续内存分配的需求背景

连续分配：浪费碎片 非连续：提高利用率和灵活性

基于不同块的大小，有两种方式：分段 分页

问题：虚拟到物理转换(软件实现 硬件实现)；选择分区块大小(段 页)

# 6.2 段式存储管理

进程的段地址空间由多个段组成：主代码段 子代码段 公共库代码段 堆栈段 ... 更细粒度和灵活的分离和共享

段表示访问方式和存储数据等属性相同的一段地址空间 对应一个连续的内存块 若干个段组成进程逻辑空间

地址的分配：地址分为段号和段偏移 用段号来查段表 可以索引到相关信息 信息是基址+长度 然后查看长度是否越界？如果没有越界 那就加上基址信息便可以找到地址

# 6.3 页式存储管理

物理空间分类的单元叫页帧 大小是2^n 为了转换方便 物理空间

同时逻辑空间也要分：逻辑叫page 物理叫frame

就需要考虑页面到页帧的转换：页表 MMU/TLB

页帧：物理内存被划分为大小相等的(f,o)

1 s f+s 有f位帧号 共有2^f个帧 o 帧内偏移 (s位 每帧有2^s个字节)

物理地址=f*2^s+o 物理地址是这么划分的

页的划分：进程逻辑地址空间被划分为大小相等的页：页内偏移=帧内偏移 通常页号大小不等于帧号大小

1 s p+s

然后转换关系：页到帧的映射 逻辑中地址中的页号是连续的 但是物理中是不连续的 不是所有页都能找到帧

转换过程：地址是(p,o) 通过p+页表基址在页表里面找内容 其中f是里面的一个内容 然后变成(f,o)

# 6.4 页表概述

每一个进程都有一个页表 

​	每个页面对应着一个页表项

​	随进程运行状态而动态变化

​	页表基址寄存器

表项组成：f帧号 标志位：存在位 修改位 引用位

存在位：是否有一个物理帧可以和它相对应 存在为1 不存在为0

修改位：内容是否修改了；引用位：是否有过引用

实际过程：**16位地址和那个物理内存大小有联系吗？和每页大小有联系吗？**

这样的问题：

1. 内存访问需要两次 第一次页表 第二次拿到数据以后访问内存
2. 页表可能很大 64位机每页1024 一个页表的大小是多少？ 解决：缓存(块表) 间接访问(多级页表)

# 6.5 快表和多级页表

快表：就是将近期访问过的页表项缓存到cpu里

tlb 关联存储器 这里有一个key 进来以后可以并行查所有表项 (p -> f)  如果匹配的上，将直接得到物理页号；如果匹配不上，需要到内存页表中寻找然后替换。

多级页表：通过简介引用将页号分成k级，来一个页表树。可以有效减少页表的大小。

# 6.6 反置页表

反置页表也是一种为了减少页表空间的技术。大地址空间的多级页表很繁琐。

页寄存器和反置页表思路：不让页表与逻辑地址空间的大小相对应/让页表与物理地址空间的大小相对应

页寄存器的实现：每个帧和页寄存器关联(此帧是否被使用；占用页号p；保护位：可读可写)

在转化的时候需要对页寄存器进行搜索，会比较麻烦...？

页寄存器中的地址转换：生成的逻辑地址转换为物理地址：

​	对逻辑地址进行hash，减少搜索的范围

​	需要解决可能的冲突

用快表缓存页表项后页寄存器的变换步骤：对逻辑地址进行hash变换，在快表中查找对应的页表项，有冲突时候可以遍历冲突链表，查找失败产生异常

实例：

![image-20210623173532894](C:\Users\12092\AppData\Roaming\Typora\typora-user-images\image-20210623173532894.png)

冲突的时候会有next指针告诉你下一项在哪...：

![image-20210623173742308](C:\Users\12092\AppData\Roaming\Typora\typora-user-images\image-20210623173742308.png)

# 6.7 段页式存储管理

段在保护方面有优势 页在交换方面有优势

就是段基础上加一个一级页表

可以方便内存共享：不同的段弄相同的页表

# 习题

页寄存器方法和反置页表的区别。