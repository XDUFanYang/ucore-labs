# 1.了解x86的特权模式

两个难点：特权级，x86内存管理单元

注意两点：程序要保护起来、普通程序不能简单访问os的空间

然后要了解mmu的工作过程

## 特权级

有几个特权级 用户？内核？ 切换？

x86有0 1 2 3四个特权级 0是内核最高特权级 一般程序放在3

一些指令只能在0特权级运行 cpu在很多情况下会做特权级检查

段选择子：在段寄存器里面，其中程序运行需要代码和数据，分别访问程序段和数据段

PRL(requested privilege level) CPL一个位于数据段，一个位于代码段 合在一起 与dpl进行比较

RPL在DS ES FS GS中 

CPL在CS SS中

访问的时候，有两个特权级，第一个就是后两位的CPL，代表当前所在数据段的优先级；RPL说明要访问的数据的优先级

DPL是描述要访问段的优先级

中断陷入异常：门情况？**没太看懂 什么叫？cpl<=DPL[门]**

访问段时的情况...

# 2.了解特权级的切换

ucore中使用中断来实现切换

什么是中断？其实会有一个中断门，然后通过中断描述符表进行跳转。

如何从0->3？：ring0产生中断，会将一些信息压栈。->会将cs中的cpl改成3，模仿ring3的形式进行修改，**这是在哪里转换的呢？**->iret指令执行以后，就会将信息弹出

如何从3->到0？：软中断，同样是在堆栈里面做修改->让其符合形式，->然后iret指令便可以让信息返回

就是切换特权级以后，是如何知道他们的地址、堆栈呢？用一个全局的TSS进行保存

访问TSS，需要使用全局描述符表，在pmm.c中建立tss

# 3.了解段页表

需要了解段表页表的格式以及信息，以及如何建立，如何操作相关项。

首先是MMU单元的实现：首先是一堆段寄存器，CS DS SS...GS;然后是有段描述符，这个是由那个段寄存器的前几位索引到的。段描述符里面有基址和限制，基址+EIP+偏移**(这个eip是什么)**，最终得到物理地址？。其中各种段的索引需要提前弄好，需要ucore进行实现。

虽然其中的GDT表很大，需要放到内存中，所以正常访问一定很慢。所以ucore需要通过硬件加速来取出信息，GDT里面有隐藏的部分，就是各种寄存器所对应的基址和限制。

x86硬件MMU建立GDT表的基址是-0xc0000000? x86 MMU建立GDT表的基址是0x0?但是需要加强页机制，弱化段机制，搞了一个使能模式？

# 4.ucore建立的段表和页表

x86页表的概述：二级页表，分三次索引:PDE->PTE->物理地址。

所以MMU页表项里面还有一些杂项。

# 5.lab2演示

利用一些工具直接把代码填过来；first-fit连续区域分配编程；实现虚拟地址的编程；释放虚拟地址
