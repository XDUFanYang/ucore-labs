# 12.1 进程切换

进程切换、切换要求、保存要求。

上下文切换：内核为了切换进程维护对应的pcb，维护状态队列。

进程标视信息、状态信息、进程所占用资源、保护现场用、队列信息。

内存地址空间结构mm_struct，说明页表啥的...

# 12.2 进程创建

不同os不同创建进程的api是不同的。

unix创建线程：fork exec 

```c++
int pid=fork();
if(pid==0){
    //子进程返回0 父进程返回子进程id 执行exec
    //系统调用exec()加载新程序取代当前运行的进程
    exec_status=exec("calc",argc,argv,...);
          }
```

从代码角度来说，fork会产生两个进程，然后就几个寄存器不一样，生成的pcb也就是pid不一样。地址空间也是如此。

![image-20210626192352626](C:\Users\12092\AppData\Roaming\Typora\typora-user-images\image-20210626192352626.png)

顺序pid和循环哪个快哪个慢都不一定的，所以pid不是递增的，是乱序的。

ucore中的do_fork()流程、结构...

空闲进程的创建、创建第一个内核线程、...

fork()的开销，vfork()

**fork子进程如果复制父进程的页表，那子进程和父进程的改动是不是同一个地方？**

# 12.3 进程加载

通过调用exec()进行进程加载。从main执行、允许加载时重新指定参数、exec调用成功(还是相同的进程、但是运行了不同的程序)、代码段和堆栈完全重写。

# 12.4 进程的等待和退出

wait() 系统调用用于父进程等待子进程的结束。子进程结束通过exit()传值，父进程通过wait()接收值并处理。

exit()功能：

![image-20210627000607610](C:\Users\12092\AppData\Roaming\Typora\typora-user-images\image-20210627000607610.png)

其他进程控制系统调用：nice()指定进程的初始优先级、进程调试支持、定时。

进程控制api导致进程状态的变化。